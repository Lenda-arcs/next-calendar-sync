---
description: Cache consistency and query alignment rules for TanStack Query + Supabase to prevent cache fragmentation and ensure optimal performance
alwaysApply: false
---
# üéØ Cache Consistency & Query Alignment

## ‚ö†Ô∏è Critical Rules to Prevent Cache Fragmentation

### 1. Hook Import Consistency

```typescript
// ‚ùå WRONG: Mixing hook sources causes cache conflicts
import { useAllTags } from '@/lib/hooks/useAppQuery'     // Returns flat array
import { useAllTags } from '@/lib/hooks/useAllTags'      // Returns structured object

// ‚úÖ CORRECT: Use the hook that matches your expected data structure
// For structured data: { allTags, userTags, globalTags }
import { useAllTags } from '@/lib/hooks/useAllTags'

// For simple array data or specific queries
import { useUserEvents, useCreateTag } from '@/lib/hooks/useAppQuery'
```

### 2. Supabase Query Parameter Validation

```typescript
// ‚ùå WRONG: Invalid Supabase parameters (causes cache mismatches)
.order('priority', { ascending: false, nullsLast: true })    // nullsLast doesn't exist!

// ‚úÖ CORRECT: Valid Supabase parameters
.order('priority', { ascending: false, nullsFirst: false })  // Puts NULLs at end
.order('priority', { ascending: false, nullsFirst: true })   // Puts NULLs at start
.order('priority', { ascending: false })                     // Default behavior
```

### 3. Smart Preloading Alignment

```typescript
// ‚úÖ CRITICAL: Preloading queries MUST match consuming components exactly

// Preloading (useSmartPreload.ts)
queryClient.prefetchQuery({
  queryKey: ['user_tags', userId],                    // ‚úÖ Same key
  queryFn: async () => {
    return supabase
      .from('tags')
      .select('*')
      .eq('user_id', userId)
      .order('priority', { ascending: false, nullsFirst: false })  // ‚úÖ Same params
  }
})

// Consuming component (useAllTags.ts)
useSupabaseQuery(
  ['user_tags', userId],                              // ‚úÖ Same key
  async (supabase) => {
    return supabase
      .from('tags')
      .select('*')
      .eq('user_id', userId)
      .order('priority', { ascending: false, nullsFirst: false })  // ‚úÖ Same params
  }
)
```

### 4. Cache Key Patterns

```typescript
// ‚úÖ STANDARD: Use these consistent cache key patterns
['user_tags', userId]           // User-specific tags
['global_tags']                 // Global tags (no userId needed)
['events', 'list', userId]      // User events list
['events', 'public', userId]    // Public events
['tag-rules', userId]           // User tag rules
['users', 'role', userId]       // User role
```

## üö® Common Pitfalls & Solutions

### Cache Miss Due to Parameter Mismatch
```typescript
// ‚ùå PROBLEM: Different ordering creates different cache signatures
// Component A
.order('name', { ascending: true, nullsFirst: false })
// Component B  
.order('name', { ascending: true })  // Default nullsFirst behavior differs!

// ‚úÖ SOLUTION: Always specify all parameters explicitly
.order('name', { ascending: true, nullsFirst: false })  // Consistent everywhere
```

### Hook Data Structure Mismatch
```typescript
// ‚ùå PROBLEM: Component expects structured data but gets flat array
const { data: tagData } = useAllTags(userId)  // From useAppQuery - returns array
const allTags = tagData?.allTags || []         // ‚ùå .allTags doesn't exist on array!

// ‚úÖ SOLUTION: Use hook that matches expected structure
const { allTags, userTags, globalTags } = useAllTags({ userId })  // From useAllTags - returns object
```

### Smart Preloading Not Working
```typescript
// ‚ùå PROBLEM: Preloading different data than what components request
// Preload: ['tags', 'all', userId] with .order('name')
// Component: ['user_tags', userId] with .order('priority')

// ‚úÖ SOLUTION: Match exactly what components need
// If component uses ['user_tags', userId], preload ['user_tags', userId]
// If component uses specific ordering, preload with same ordering
```

## üîç Debugging Cache Issues

### Check TanStack Query DevTools
```typescript
// Look for these warning signs:
// 1. "disabled" queries in logs - indicates unused cache keys
// 2. Multiple similar cache keys - indicates fragmentation  
// 3. Same data fetched multiple times - indicates cache misses

// Example problematic log:
["tags","all","userId"] disabled     // ‚ùå Unused/conflicting key
["user_tags","userId"]               // ‚úÖ Active key
["global_tags"]                      // ‚úÖ Active key
```

### Network Tab Analysis
```typescript
// ‚úÖ GOOD: After preloading, no duplicate requests
// Hover trigger: tags?select=*&eq.user_id... (preload)
// Page load: (no additional tag requests)

// ‚ùå BAD: Duplicate requests despite preloading
// Hover trigger: tags?...&order=priority.desc.nullsFirst=false
// Page load: tags?...&order=priority.desc               // Different query!
```

## üìã Checklist Before Committing

- [ ] All Supabase \`.order()\` calls use valid parameters (\`nullsFirst\`, not \`nullsLast\`)
- [ ] Smart preloading cache keys match consuming component cache keys exactly
- [ ] Query parameters (select, order, filters) match between preload and consumption
- [ ] Components import hooks that match their expected data structure
- [ ] No "disabled" queries in TanStack Query logs
- [ ] Network tab shows no duplicate requests after successful preloading

## üéØ Performance Goals

- **Cache Hit Rate**: >90% for preloaded resources
- **Navigation Speed**: <100ms for preloaded pages
- **Network Requests**: Zero duplicates for cached queries
- **TanStack Logs**: Clean with no disabled/orphaned queries

## üìã Architecture Guidelines

### Client-Side vs Server-Side Data Fetching

```typescript
// ‚úÖ PREFERRED: Client-side data fetching for /app pages
// Benefits: Cache integration, optimistic updates, consistent architecture

// page.tsx (Server Component)
export default async function ProfilePage({ params }) {
  const { user } = await supabase.auth.getUser()
  return <ProfileClient userId={user.id} />  // Just pass ID
}

// ProfileClient.tsx (Client Component)
export default function ProfileClient({ userId }) {
  const { data: user, isLoading, error } = useUserProfile(userId)
  return <DataLoader data={user} loading={isLoading} error={error}>
    {(user) => <ProfileContent user={user} />}
  </DataLoader>
}

// ‚ùå AVOID: Server-side data fetching for /app pages
// Problems: Bypasses cache, inconsistent with preloading, no optimistic updates
export default async function ProfilePage() {
  const { data: user } = await supabase.from('users').select('*')  // ‚ùå Bypasses cache
  return <ProfileContent user={user} />
}
```

### When to Use Each Approach

**Use Client-Side (useQuery hooks) for:**
- Authenticated user pages (/app/*)
- Pages that need optimistic updates
- Pages with preloading
- Pages that update frequently

**Use Server-Side (direct Supabase) for:**
- Public pages (SEO important)
- One-time data that doesn't change
- Initial app shell data
