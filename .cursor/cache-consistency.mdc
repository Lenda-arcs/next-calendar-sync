---
description: Cache consistency and query alignment rules for TanStack Query + Supabase to prevent cache fragmentation and ensure optimal performance
alwaysApply: false
---
# üéØ Cache Consistency & Query Alignment

## ‚ö†Ô∏è Critical Rules to Prevent Cache Fragmentation

### 1. Hook Import Consistency

```typescript
// ‚ùå WRONG: Mixing hook sources causes cache conflicts
import { useAllTags } from '@/lib/hooks/useAppQuery'     // Returns flat array
import { useAllTags } from '@/lib/hooks/useAllTags'      // Returns structured object

// ‚úÖ CORRECT: Use the hook that matches your expected data structure
// For structured data: { allTags, userTags, globalTags }
import { useAllTags } from '@/lib/hooks/useAllTags'

// For simple array data or specific queries
import { useUserEvents, useCreateTag } from '@/lib/hooks/useAppQuery'
```

### 2. Supabase Query Parameter Validation

```typescript
// ‚ùå WRONG: Invalid Supabase parameters (causes cache mismatches)
.order('priority', { ascending: false, nullsLast: true })    // nullsLast doesn't exist!

// ‚úÖ CORRECT: Valid Supabase parameters
.order('priority', { ascending: false, nullsFirst: false })  // Puts NULLs at end
.order('priority', { ascending: false, nullsFirst: true })   // Puts NULLs at start
.order('priority', { ascending: false })                     // Default behavior
```

### 3. Smart Preloading Alignment

```typescript
// ‚úÖ CRITICAL: Preloading queries MUST match consuming components exactly

// Preloading (useSmartPreload.ts)
queryClient.prefetchQuery({
  queryKey: ['user_tags', userId],                    // ‚úÖ Same key
  queryFn: async () => {
    return supabase
      .from('tags')
      .select('*')
      .eq('user_id', userId)
      .order('priority', { ascending: false, nullsFirst: false })  // ‚úÖ Same params
  }
})

// Consuming component (useAllTags.ts)
useSupabaseQuery(
  ['user_tags', userId],                              // ‚úÖ Same key
  async (supabase) => {
    return supabase
      .from('tags')
      .select('*')
      .eq('user_id', userId)
      .order('priority', { ascending: false, nullsFirst: false })  // ‚úÖ Same params
  }
)
```

### 4. Cache Key Patterns

```typescript
// ‚úÖ STANDARD: Use these consistent cache key patterns
['user_tags', userId]           // User-specific tags
['global_tags']                 // Global tags (no userId needed)
['events', 'list', userId]      // User events list
['events', 'public', userId]    // Public events
['tag-rules', userId]           // User tag rules
['users', 'role', userId]       // User role
```

## üö® Common Pitfalls & Solutions

### Cache Miss Due to Parameter Mismatch
```typescript
// ‚ùå PROBLEM: Different ordering creates different cache signatures
// Component A
.order('name', { ascending: true, nullsFirst: false })
// Component B  
.order('name', { ascending: true })  // Default nullsFirst behavior differs!

// ‚úÖ SOLUTION: Always specify all parameters explicitly
.order('name', { ascending: true, nullsFirst: false })  // Consistent everywhere
```

### Hook Data Structure Mismatch
```typescript
// ‚ùå PROBLEM: Component expects structured data but gets flat array
const { data: tagData } = useAllTags(userId)  // From useAppQuery - returns array
const allTags = tagData?.allTags || []         // ‚ùå .allTags doesn't exist on array!

// ‚úÖ SOLUTION: Use hook that matches expected structure
const { allTags, userTags, globalTags } = useAllTags({ userId })  // From useAllTags - returns object
```

### Smart Preloading Not Working
```typescript
// ‚ùå PROBLEM: Preloading different data than what components request
// Preload: ['tags', 'all', userId] with .order('name')
// Component: ['user_tags', userId] with .order('priority')

// ‚úÖ SOLUTION: Match exactly what components need
// If component uses ['user_tags', userId], preload ['user_tags', userId]
// If component uses specific ordering, preload with same ordering
```

### üö® Query Key Mismatch in Preloading (Critical)
```typescript
// ‚ùå CRITICAL PROBLEM: Preload and hook use different query keys
// Preload function:
queryKey: ['calendar-feeds', userId]

// Hook:
queryKey: queryKeys.calendarFeeds.userFeeds(userId)  // ['calendar-feeds', 'user', userId]

// Result: No preloading works, network requests after page load

// ‚úÖ SOLUTION: Always use queryKeys helpers in preloading
// Both preload and hook should use:
queryKey: queryKeys.calendarFeeds.userFeeds(userId)
queryFn: () => dataAccess.getUserCalendarFeeds(supabase, userId)

// üîç DETECTION: 
// - No requests in Network tab on hover
// - Requests fire after navigating to page
// - Cache misses in TanStack DevTools
```

## üîç Debugging Cache Issues

### Check TanStack Query DevTools
```typescript
// Look for these warning signs:
// 1. "disabled" queries in logs - indicates unused cache keys
// 2. Multiple similar cache keys - indicates fragmentation  
// 3. Same data fetched multiple times - indicates cache misses

// Example problematic log:
["tags","all","userId"] disabled     // ‚ùå Unused/conflicting key
["user_tags","userId"]               // ‚úÖ Active key
["global_tags"]                      // ‚úÖ Active key
```

### Network Tab Analysis
```typescript
// ‚úÖ GOOD: After preloading, no duplicate requests
// Hover trigger: tags?select=*&eq.user_id... (preload)
// Page load: (no additional tag requests)

// ‚ùå BAD: Duplicate requests despite preloading
// Hover trigger: tags?...&order=priority.desc.nullsFirst=false
// Page load: tags?...&order=priority.desc               // Different query!
```

## üìã Checklist Before Committing

- [ ] All Supabase \`.order()\` calls use valid parameters (\`nullsFirst\`, not \`nullsLast\`)
- [ ] Smart preloading cache keys match consuming component cache keys exactly
- [ ] Query parameters (select, order, filters) match between preload and consumption
- [ ] Components import hooks that match their expected data structure
- [ ] No "disabled" queries in TanStack Query logs
- [ ] Network tab shows no duplicate requests after successful preloading

## üéØ Performance Goals

- **Cache Hit Rate**: >90% for preloaded resources
- **Navigation Speed**: <100ms for preloaded pages
- **Network Requests**: Zero duplicates for cached queries
- **TanStack Logs**: Clean with no disabled/orphaned queries

## üìã Architecture Guidelines

### Client-Side vs Server-Side Data Fetching

```typescript
// ‚úÖ PREFERRED: Client-side data fetching for /app pages
// Benefits: Cache integration, optimistic updates, consistent architecture

// page.tsx (Server Component)
export default async function ProfilePage({ params }) {
  const { user } = await supabase.auth.getUser()
  return <ProfileClient userId={user.id} />  // Just pass ID
}

// ProfileClient.tsx (Client Component)
export default function ProfileClient({ userId }) {
  const { data: user, isLoading, error } = useUserProfile(userId)
  return <DataLoader data={user} loading={isLoading} error={error}>
    {(user) => <ProfileContent user={user} />}
  </DataLoader>
}

// ‚ùå AVOID: Server-side data fetching for /app pages
// Problems: Bypasses cache, inconsistent with preloading, no optimistic updates
export default async function ProfilePage() {
  const { data: user } = await supabase.from('users').select('*')  // ‚ùå Bypasses cache
  return <ProfileContent user={user} />
}
```

### When to Use Each Approach

**Use Client-Side (useQuery hooks) for:**
- Authenticated user pages (/app/*)
- Pages that need optimistic updates
- Pages with preloading
- Pages that update frequently

**Use Server-Side (direct Supabase) for:**
- Public pages (SEO important)
- One-time data that doesn't change
- Initial app shell data
- Layout components (navigation, auth state)

### Middleware Auth Protection

```typescript
// ‚úÖ GOOD: Middleware already protects /app routes
// No need for redundant auth checks in page components

// page.tsx (Server Component)
export default async function ProfilePage() {
  const supabase = await createServerClient()
  const { data: { user } } = await supabase.auth.getUser()  // ‚úÖ Simple, middleware guarantees user exists
  return <ProfileClient userId={user!.id} />
}

// ‚ùå BAD: Redundant auth checks when middleware already handles it
export default async function ProfilePage() {
  const supabase = await createServerClient()
  const { data: { user }, error } = await supabase.auth.getUser()
  
  if (error || !user) {  // ‚ùå Unnecessary - middleware already handles this
    redirect('/auth/sign-in')
  }
  return <ProfileClient userId={user.id} />
}
```

### Data Fetching Optimizations

```typescript
// ‚úÖ GOOD: Calculate counts from existing data
const { data: calendarFeeds } = useCalendarFeeds(userId)
const feedsCount = calendarFeeds?.length || 0  // ‚úÖ No extra query needed

// ‚ùå BAD: Separate count queries
const { data: calendarFeeds } = useCalendarFeeds(userId)
const { count: feedsCount } = useSupabaseQuery(['feeds-count'], ...)  // ‚ùå Redundant
```

### Layout Component Optimization

```typescript
// ‚úÖ GOOD: Single efficient query in layout
const { data: userProfile } = await supabase
  .from('users')
  .select('*')  // Get all needed data at once
  .eq('id', user.id)
  .single()

const userRole = userProfile?.role || 'user'
const profileImage = userProfile?.profile_image_url

// ‚ùå BAD: Multiple redundant queries  
const { data: userData } = await supabase
  .from('users')
  .select('role, profile_image_url')  // Query 1
  .eq('id', user.id)
  .single()

const { data: userProfile } = await supabase
  .from('users') 
  .select('*')  // Query 2 - duplicates data!
  .eq('id', user.id)
  .single()
```

### Passing Data to Client Components

```typescript
// ‚úÖ GOOD: Pass data from server to client components
// Layout (server):
const { data: { user } } = await supabase.auth.getUser()
return <ActiveHomeLink userId={user.id} />

// Component (client):
export function HomeLinkClient({ userId }) {
  const { preloadDashboard } = useSmartPreload()
  return <div onMouseEnter={() => preloadDashboard(userId)}>

// ‚ùå BAD: Client component trying to get server data
export function HomeLinkClient() {
  const { user } = useAuth()  // ‚ùå Error: useAuth must be used within AuthProvider
```
